# Phase 1: CUI版1人用麻雀（索子のみ）実装方針

## 概要

Phase 1では、最もシンプルな麻雀ゲームを実装します。索子のみを使用した1人用のCUIゲームで、基本的な麻雀のルールと和了判定を学習・実装することが目的です。

## 実装方針

### 1. 段階的開発アプローチ

#### 1.1 Bottom-Upアプローチ

- 最小単位（牌）から開始し、徐々に複雑なシステム（ゲーム全体）を構築
- 各コンポーネントを独立してテスト可能な設計

#### 1.2 TDD（テスト駆動開発）

1. **Red**: テストを書いて失敗させる
2. **Green**: テストを通すための最小限の実装
3. **Refactor**: コードの改善とリファクタリング

### 2. アーキテクチャ設計

#### 2.1 レイヤー構造

```
┌─────────────────────────┐
│     UI Layer (CUI)      │  ← ユーザーインターフェース
├─────────────────────────┤
│   Game Logic Layer      │  ← ゲームフロー制御
├─────────────────────────┤
│   Domain Logic Layer    │  ← 麻雀ルール・和了判定
├─────────────────────────┤
│    Data Model Layer     │  ← 牌、手牌等のデータ構造
└─────────────────────────┘
```

#### 2.2 主要コンポーネント

1. **Tile（牌）**: 最小単位のデータ構造
2. **Hand（手牌）**: 牌の集合を管理
3. **WallTiles（山牌）**: ゲーム用の牌山を管理
4. **WinningChecker（和了判定）**: 和了形かどうかの判定
5. **ShantenCalculator（向聴数計算）**: テンパイ判定用
6. **GameEngine（ゲームエンジン）**: ゲーム全体の進行制御
7. **CUIInterface（CUIインターフェース）**: ユーザー操作の入出力

### 3. データ設計

#### 3.1 牌（Tile）の表現

**仕様書の要件**:

- 辞書型オブジェクト: `{'suit': 'sou', 'value': 1-9}`
- 内部表現: 数値ID（0-35）も併用

**設計方針**:

```python
@dataclass(frozen=True)
class Tile:
    """麻雀の牌を表現するイミュータブルクラス"""
    suit: str  # 'sou'（索子）
    value: int  # 1-9

    @property
    def tile_id(self) -> int:
        """将来の拡張に備えた数値ID（0-35: 索子）"""
        return self.value - 1  # 0-8
```

**選択理由**:

- `@dataclass(frozen=True)`: イミュータブルで値オブジェクトとして扱える
- `tile_id`プロパティ: Phase 5での全牌種対応時の拡張性を確保

#### 3.2 手牌（Hand）の管理

**仕様書の要件**:

- データ構造: リスト（List[Tile]）
- ソート方法: value昇順
- ソートタイミング: 常時ソート状態を維持

**設計方針**:

```python
class Hand:
    """手牌を管理するクラス"""
    _tiles: List[Tile]

    def add_tile(self, tile: Tile) -> None:
        """牌を追加（自動ソート）"""

    def remove_tile(self, tile: Tile) -> None:
        """牌を除去"""

    @property
    def tiles(self) -> List[Tile]:
        """ソート済み牌リストの読み取り専用ビュー"""
```

### 4. 和了判定の設計

#### 4.1 アルゴリズム設計

**仕様書の要件**:

- 通常形: 再帰的探索（雀頭選択→面子判定）
- 七対子: 7つの対子の確認
- 計算量: O(n^2)程度（n=14）

**実装方針**:

1. **分離された責務**: 通常形と七対子を別々のアルゴリズムで実装
2. **再帰的探索**: 雀頭候補を選択→残りの牌で面子を構成可能かチェック
3. **効率化**: 牌の種類別カウント（Counter）を活用

#### 4.2 実装段階

1. **基本実装**: シンプルな再帰的探索
2. **最適化**: 必要に応じてメモ化やアルゴリズム改善

### 5. 向聴数計算の設計

**目的**: リーチ判定（0向聴 = テンパイ）

**実装方針**:

- 和了判定の応用として実装
- 各牌を捨てた時の向聴数変化を計算
- 最小向聴数を返す

### 6. CUIインターフェース設計

#### 6.1 画面レイアウト（仕様書準拠）

```
========================================
ターン: 10 | 残り山牌: 12枚 | 嶺上牌: 4枚
リーチ: OFF
========================================

あなたの捨て牌:
1索 2索 3索 4索 5索 6索 7索
8索 9索 1索 [2索] 3索 4索
（[]はリーチ宣言牌）

----------------------------------------

あなたの手牌:
[1] 1索  [2] 1索  [3] 2索  [4] 3索  [5] 4索
[6] 5索  [7] 6索  [8] 7索  [9] 8索  [10] 9索
[11] 9索  [12] 9索  [13] 9索

ツモ牌: [14] 3索

選択可能なアクション:
1. 打牌する（1-14の番号を入力）
2. カン（可能な場合のみ表示）
3. リーチ（テンパイ時のみ表示）
4. ツモ和了（和了時のみ表示）

アクションを選択してください:
```

#### 6.2 設計方針

- **表示の責務分離**: ゲーム状態の表示とユーザー入力を分離
- **入力検証**: 不正入力に対する適切なエラーハンドリング
- **状態ベース**: 現在のゲーム状態に応じた選択肢の動的表示

### 7. エラーハンドリング設計

#### 7.1 例外戦略

- **検証例外**: 不正な入力や状態に対してはValueError等で明確にエラー
- **回復可能**: ユーザー入力エラーは再入力で回復
- **致命的エラー**: プログラムの不整合は即座に停止

#### 7.2 実装指針

```python
class InvalidTileError(ValueError):
    """不正な牌に関するエラー"""
    pass

class InvalidGameStateError(Exception):
    """不正なゲーム状態エラー"""
    pass
```

### 8. テスト戦略

#### 8.1 テストレベル

1. **単体テスト**: 各クラス・メソッドの個別テスト
2. **結合テスト**: コンポーネント間の連携テスト
3. **統合テスト**: ゲーム全体のシナリオテスト

#### 8.2 テストケース設計

- **正常系**: 期待される動作の確認
- **異常系**: エラー条件での適切な例外処理
- **境界値**: 最小・最大値での動作確認
- **エッジケース**: 特殊な組み合わせでの動作確認

#### 8.3 テストデータ

```python
# 和了形テストケース
WINNING_HANDS = [
    # 通常形（4面子1雀頭）
    [1,1,2,3,4,5,6,7,8,9,9,9,9,9],  # 一九刻子+順子
    # 七対子
    [1,1,2,2,3,3,4,4,5,5,6,6,7,7],  # 七対子
]

# 非和了形テストケース
NON_WINNING_HANDS = [
    [1,2,3,4,5,6,7,8,9,9,9,9,9,9],  # 15枚（異常）
    [1,1,1,2,3,4,5,6,7,8,9,9,9],    # 13枚（不完全）
]
```

### 9. パフォーマンス考慮事項

#### 9.1 Phase 1での目標

- **和了判定**: 10ms以内（仕様書要件）
- **レスポンス**: ユーザー入力から画面更新まで100ms以内

#### 9.2 最適化方針

1. **必要最小限**: 過度な最適化は避け、まず動作する実装を優先
2. **計測ベース**: 実際のボトルネックを計測してから最適化
3. **将来への備え**: Phase 5でのAI実装を見据えたスケーラブルな設計

### 10. 実装順序

#### 10.1 第1段階: 基盤構築

1. Tileクラス（データ構造の基盤）
2. Handクラス（手牌管理）
3. 基本的な例外クラス

#### 10.2 第2段階: ロジック実装

1. 基本的な和了判定（通常形）
2. 七対子の和了判定
3. 向聴数計算

#### 10.3 第3段階: ゲーム機能

1. WallTilesクラス（山牌管理）
2. GameEngineクラス（ゲーム進行）
3. CUIインターフェース

#### 10.4 第4段階: 高度な機能

1. リーチ機能
2. 暗槓機能
3. デバッグモード

### 11. 将来への拡張性

#### 11.1 Phase 2以降への考慮

- **牌ID設計**: 全牌種（萬子・筒子・字牌）への拡張を考慮
- **インターフェース**: CUIからWebUIへの移行を考慮
- **AI拡張**: AIプレイヤーの追加を考慮した設計

#### 11.2 コード構造

- **依存関係**: 上位レイヤーは下位レイヤーに依存、逆は禁止
- **インターフェース**: 具象クラスではなくabstract base classを活用
- **設定の外部化**: ハードコードを避け、設定ファイルで調整可能に

## まとめ

Phase 1は麻雀AIプロジェクトの基盤となる重要なフェーズです。シンプルな実装から始めて、段階的に複雑な機能を追加していく方針で、TDDを徹底して品質を確保しながら進めます。

各コンポーネントは独立性を保ち、将来のPhaseでの拡張を考慮した設計を心がけることで、長期的なプロジェクト成功を目指します。
